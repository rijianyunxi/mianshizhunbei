<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç®€æ˜“å·¥ä½œæµè®¾è®¡å™¨ (Canvasç‰ˆ)</title>
    <!-- å¼•å…¥ Font Awesome æ ·å¼ç”¨äºèŠ‚ç‚¹å›¾æ ‡ -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css">
    <style>
        /* 1. è°ƒæ•´ä¸»è¦é¢œè‰²å’Œé¢æ¿å®½åº¦ */
        :root {
            --primary-color: #409eff; /* ç°ä»£åŒ–è“è‰² */
            --bg-color: #f0f2f5;
            --panel-width: 240px; /* å±æ€§é¢æ¿å®½åº¦è°ƒæ•´ä¸º 240px */
        }

        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            overflow: hidden;
            background-color: var(--bg-color);
            display: flex;
            height: 100vh; /* ç¡®ä¿å æ»¡è§†å£é«˜åº¦ */
        }

        /* å·¦ä¾§å·¥å…·æ  */
        .toolbar {
            width: 60px;
            background: #fff;
            border-right: 1px solid #e0e0e0; /* è¾¹æ¡†æ›´æŸ”å’Œ */
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-top: 20px;
            z-index: 10;
        }

        .tool-item {
            width: 40px;
            height: 40px;
            margin-bottom: 15px;
            border: 1px solid #f0f0f0;
            border-radius: 8px; /* å¢åŠ åœ†è§’ */
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 14px; /* å¢å¤§å›¾æ ‡å°ºå¯¸ */
            background: #fff;
            transition: all 0.3s;
            user-select: none;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05); /* è½»å¾®é˜´å½± */
        }

        .tool-item:hover {
            border-color: var(--primary-color);
            background-color: #ecf5ff;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        /* ä¸­é—´ç”»å¸ƒåŒºåŸŸ */
        .canvas-container {
            flex: 1;
            position: relative;
            background-color: var(--bg-color); /* çº¯è‰²èƒŒæ™¯ */
            overflow: hidden;
            /* é¼ æ ‡åœ¨ç”»å¸ƒç©ºç™½å¤„æ˜¾ç¤ºä¸ºæ‹–åŠ¨å›¾æ ‡ */
            cursor: grab; 
        }
        .canvas-container:active {
            cursor: grabbing;
        }

        canvas {
            display: block;
            /* è¦†ç›–é»˜è®¤çš„æŠ“æ‰‹å›¾æ ‡ï¼Œç¡®ä¿æ‹–åŠ¨èŠ‚ç‚¹æ—¶æ¢å¤é»˜è®¤å…‰æ ‡ */
            cursor: default !important;
        }

        /* å³ä¾§å±æ€§é¢æ¿ */
        .properties-panel {
            width: var(--panel-width);
            background: #fff;
            border-left: 1px solid #e0e0e0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            z-index: 10;
        }

        .panel-header {
            font-size: 18px; /* å¢å¤§æ ‡é¢˜ */
            font-weight: 600;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
            color: #333;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 6px;
            font-size: 13px;
            color: #666;
            font-weight: 500;
        }

        .form-group input, .form-group select {
            width: 100%;
            padding: 9px 12px; /* å¢å¤§å†…è¾¹è· */
            border: 1px solid #dcdfe6;
            border-radius: 6px;
            box-sizing: border-box;
            transition: border-color 0.2s;
        }
        .form-group input:focus {
            border-color: var(--primary-color);
            outline: none;
        }
        
        .form-group textarea {
            width: 100%;
            padding: 9px 12px;
            border: 1px solid #dcdfe6;
            border-radius: 6px;
            box-sizing: border-box;
            resize: vertical;
            font-size: 14px;
            font-family: inherit;
        }
        .form-group textarea:focus {
            border-color: var(--primary-color);
            outline: none;
        }

        .btn {
            padding: 10px 15px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            margin-right: 10px;
            color: #fff;
            transition: opacity 0.2s, transform 0.1s;
        }
        .btn:hover { opacity: 0.9; }
        .btn:active { transform: translateY(1px); }

        .btn-primary { background-color: var(--primary-color); }
        .btn-danger { background-color: #f56c6c; }
        .btn-success { background-color: #67c23a; }
        .btn-secondary { background-color: #909399; }

        /* 2. è°ƒæ•´æ“ä½œæ ä½ç½®ä»¥é€‚åº”æ–°çš„é¢æ¿å®½åº¦ */
        .action-bar {
            position: absolute;
            top: 15px;
            right: 260px; /* 240px (Panel) + 20px (Padding) */
            z-index: 5;
        }
        
        .empty-state {
            color: #a0a0a0;
            font-style: italic;
            text-align: center;
            padding: 40px 0;
            border: 1px dashed #e0e0e0;
            border-radius: 6px;
        }

        /* æç¤º */
        .toast {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            color: #fff;
            padding: 10px 20px;
            border-radius: 4px;
            display: none;
            z-index: 100;
            font-size: 14px;
        }
        
        /* èŠ‚ç‚¹å›¾æ ‡æ ·å¼ */
        .node-icon {
            font-size: 1.5em; /* å¢å¤§å›¾æ ‡å°ºå¯¸ */
        }
    </style>
</head>
<body>

    <!-- å·¥å…·æ  -->
    <div class="toolbar">
        <div class="tool-item" onclick="app.addNode('start')" title="å¼€å§‹èŠ‚ç‚¹ (â–¶ï¸)">
            <i class="fas fa-play" style="color:#67c23a;"></i>
        </div>
        <div class="tool-item" onclick="app.addNode('task')" title="ä»»åŠ¡èŠ‚ç‚¹">
            <i class="fas fa-tasks" style="color:#409eff;"></i>
        </div>
        <div class="tool-item" onclick="app.addNode('end')" title="ç»“æŸèŠ‚ç‚¹ (ğŸ›‘)">
            <i class="fas fa-stop" style="color:#f56c6c;"></i>
        </div>
        <div class="tool-item" id="linkModeBtn" onclick="app.toggleLinkMode()" title="è¿çº¿æ¨¡å¼ (L)">
            <i class="fas fa-link"></i>
        </div>
    </div>

    <!-- ç”»å¸ƒ -->
    <div class="canvas-container" id="canvasContainer">
        <div class="action-bar">
            <button class="btn btn-success" onclick="app.saveData()">ä¿å­˜/å¯¼å‡ºæ•°æ® & æ ¡éªŒ</button>
            <button class="btn btn-secondary" onclick="app.loadDemoData()">å›æ˜¾Demoæ•°æ®</button>
            <button class="btn btn-danger" onclick="app.clear()">æ¸…ç©º</button>
        </div>
        <canvas id="workflowCanvas"></canvas>
    </div>

    <!-- å±æ€§é¢æ¿ -->
    <div class="properties-panel" id="propertiesPanel">
        <div class="panel-header">å±æ€§é…ç½®</div>
        <div id="propContent">
            <div class="empty-state">è¯·ç‚¹å‡»é€‰æ‹©èŠ‚ç‚¹æˆ–è¿çº¿</div>
        </div>
    </div>

    <div class="toast" id="toast">æç¤ºä¿¡æ¯</div>

<script>
/**
 * ç®€æ˜“å·¥ä½œæµè®¾è®¡å™¨æ ¸å¿ƒé€»è¾‘
 */
class WorkflowDesigner {
    constructor(canvasId, containerId) {
        this.canvas = document.getElementById(canvasId);
        this.container = document.getElementById(containerId);
        this.ctx = this.canvas.getContext('2d');
        
        // æ•°æ®æ¨¡å‹
        this.nodes = [];
        this.edges = [];
        
        // çŠ¶æ€ç®¡ç†
        this.isDragging = false;
        this.dragTarget = null; // Either a node or { isCanvas: true }
        this.selectedElement = null; // Node or Edge
        this.isLinkMode = false;
        this.tempLine = null;
        this.linkingSource = null;

        // é…ç½® (åŒ…å«ç¼©æ”¾å’Œå¹³ç§»çŠ¶æ€)
        this.config = {
            nodeWidth: 140, 
            nodeHeight: 60,
            radius: 30, 
            gridSize: 20,
            scale: 1, // ç¼©æ”¾æ¯”ä¾‹
            panX: 0,  // å¹³ç§»X
            panY: 0   // å¹³ç§»Y
        };

        this.init();
    }

    init() {
        // å“åº”å¼ç”»å¸ƒå¤§å° & é«˜åˆ†å±DPIä¿®å¤
        this.resizeCanvas();
        window.addEventListener('resize', () => this.resizeCanvas());

        // ç»‘å®šäº‹ä»¶
        this.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));
        this.canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));
        this.canvas.addEventListener('mouseup', this.handleMouseUp.bind(this));
        this.canvas.addEventListener('wheel', this.handleWheel.bind(this)); // æ»šè½®ç¼©æ”¾
        
        // é”®ç›˜å¿«æ·é”®
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Delete' || e.key === 'Backspace') {
                if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA') this.deleteSelected();
            }
            if (e.key.toLowerCase() === 'l') this.toggleLinkMode();
        });

        this.render();
    }

    // ==================== ç¼©æ”¾å’Œå¹³ç§»æ ¸å¿ƒé€»è¾‘ ====================

    // ä¿®å¤é«˜åˆ†å±æ¨¡ç³Šé—®é¢˜ï¼Œå¹¶è®¾ç½®æ˜¾ç¤ºå°ºå¯¸
    setCanvasScale() {
        const dpr = window.devicePixelRatio || 1;
        const width = this.container.clientWidth;
        const height = this.container.clientHeight;

        // è®¾ç½®ç»˜å›¾ç¼“å†²åŒºå¤§å°ï¼ˆä¹˜ä»¥DPRï¼‰
        this.canvas.width = width * dpr;
        this.canvas.height = height * dpr;

        // è®¾ç½®æ˜¾ç¤ºå¤§å°ï¼ˆCSSå¤§å°ï¼‰
        this.canvas.style.width = width + 'px';
        this.canvas.style.height = height + 'px';

        // ç¼©æ”¾ç»˜å›¾ä¸Šä¸‹æ–‡ï¼Œä¿è¯æ‰€æœ‰ç»˜åˆ¶æŒ‡ä»¤éƒ½é€‚é…DPR
        this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0); 
    }

    resizeCanvas() {
        this.setCanvasScale();
        this.render();
    }
    
    // å°†å±å¹•åæ ‡è½¬æ¢ä¸ºç”»å¸ƒï¼ˆä¸–ç•Œï¼‰åæ ‡
    getCanvasCoords(screenX, screenY) {
        const realX = (screenX - this.config.panX) / this.config.scale;
        const realY = (screenY - this.config.panY) / this.config.scale;
        return { realX, realY };
    }

    handleWheel(e) {
        e.preventDefault();
        const scaleFactor = 1.1;
        const delta = e.deltaY > 0 ? 1 / scaleFactor : scaleFactor;
        
        // ç¼©æ”¾ç›¸å¯¹äºé¼ æ ‡ä½ç½®
        const mouseX = e.offsetX;
        const mouseY = e.offsetY;

        const oldScale = this.config.scale;
        let newScale = oldScale * delta;
        
        // é™åˆ¶ç¼©æ”¾èŒƒå›´
        newScale = Math.min(2.0, Math.max(0.3, newScale));
        if (newScale === oldScale) return;

        // è®¡ç®—å¹³ç§»è°ƒæ•´ï¼Œä»¥å®ç°ä»¥å…‰æ ‡ä¸ºä¸­å¿ƒçš„ç¼©æ”¾
        this.config.panX = mouseX - (mouseX - this.config.panX) * (newScale / oldScale);
        this.config.panY = mouseY - (mouseY - this.config.panY) * (newScale / oldScale);
        this.config.scale = newScale;

        this.render();
    }

    // ==================== æ•°æ®æ“ä½œ ====================

    // ç”ŸæˆUUID
    generateId() {
        return 'node_' + Math.random().toString(36).substr(2, 9);
    }

    // æ·»åŠ èŠ‚ç‚¹
    addNode(type) {
        // é»˜è®¤ä½ç½®åœ¨ç”»å¸ƒä¸­å¿ƒï¼Œéœ€è¦è½¬æ¢åˆ°ä¸–ç•Œåæ ‡
        const centerX = this.canvas.width / (window.devicePixelRatio || 1) / 2;
        const centerY = this.canvas.height / (window.devicePixelRatio || 1) / 2;
        const { realX: x, realY: y } = this.getCanvasCoords(centerX, centerY);

        const newNode = {
            id: this.generateId(),
            type: type, // 'start', 'task', 'end'
            x: x + (Math.random() * 40 - 20) / this.config.scale,
            y: y + (Math.random() * 40 - 20) / this.config.scale,
            label: type === 'task' ? 'æ–°ä»»åŠ¡èŠ‚ç‚¹ï¼Œå¯æ‹–åŠ¨ä¿®æ”¹åç§°' : '', // å¼€å§‹/ç»“æŸèŠ‚ç‚¹ä¸å†æ˜¾ç¤ºæ–‡å­—
            // ä¸šåŠ¡å±æ€§
            props: {
                personnel: '', // ç»åŠäºº
                isCompleted: type === 'task' ? 'æœªå®Œæˆ' : 'N/A', // æ–°å¢ä»»åŠ¡å®ŒæˆçŠ¶æ€
                description: ''
            }
        };
        this.nodes.push(newNode);
        this.selectElement(newNode);
        this.render();
        this.showToast('å·²æ·»åŠ èŠ‚ç‚¹');
    }

    // æ·»åŠ è¿çº¿
    addEdge(sourceId, targetId) {
        // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
        const exist = this.edges.find(e => e.source === sourceId && e.target === targetId);
        if (exist) {
            this.showToast('è¿çº¿å·²å­˜åœ¨');
            return;
        }
        
        // ä¸å…è®¸è‡ªæŒ‡
        if (sourceId === targetId) {
            this.showToast('ä¸èƒ½è‡ªè¿');
            return;
        }

        const sourceNode = this.nodes.find(n => n.id === sourceId);
        const targetNode = this.nodes.find(n => n.id === targetId);
        
        // å¼ºåŒ–è¿çº¿è§„åˆ™: 
        // 1. ä¸å…è®¸ä»ç»“æŸèŠ‚ç‚¹è¿å‡º
        if (sourceNode.type === 'end') {
            this.showToast('ä¸å…è®¸ä» "ç»“æŸèŠ‚ç‚¹" è¿å‡º');
            return;
        }
        // 2. ä¸å…è®¸è¿å‘å¼€å§‹èŠ‚ç‚¹
        if (targetNode.type === 'start') {
            this.showToast('ä¸å…è®¸è¿å‘ "å¼€å§‹èŠ‚ç‚¹"');
            return;
        }
        // 3. ä¸å…è®¸å¼€å§‹èŠ‚ç‚¹è¿å‘å¼€å§‹èŠ‚ç‚¹ (å·²åŒ…å«åœ¨è§„åˆ™2ä¸­ï¼Œä½†æ˜ç¡®åˆ—å‡º)
        if (sourceNode.type === 'start' && targetNode.type === 'start') {
             this.showToast('ä¸å…è®¸å¼€å§‹èŠ‚ç‚¹ä¹‹é—´è¿çº¿');
             return;
        }
        
        const newEdge = {
            id: 'edge_' + Math.random().toString(36).substr(2, 9),
            source: sourceId,
            target: targetId,
            label: ''
        };
        this.edges.push(newEdge);
        this.selectElement(newEdge);
        this.render();
    }

    // åˆ é™¤é€‰ä¸­é¡¹
    deleteSelected() {
        if (!this.selectedElement) {
            this.showToast('è¯·å…ˆé€‰ä¸­ä¸€ä¸ªå…ƒç´ ');
            return;
        }

        if (confirm('ç¡®å®šåˆ é™¤é€‰ä¸­å…ƒç´ å—ï¼Ÿ')) { 
            if (this.selectedElement.source) {
                // åˆ é™¤çº¿
                this.edges = this.edges.filter(e => e.id !== this.selectedElement.id);
                this.showToast('å·²åˆ é™¤è¿çº¿');
            } else {
                // åˆ é™¤èŠ‚ç‚¹ï¼ŒåŒæ—¶åˆ é™¤å…³è”çš„çº¿
                const nodeId = this.selectedElement.id;
                this.nodes = this.nodes.filter(n => n.id !== nodeId);
                this.edges = this.edges.filter(e => e.source !== nodeId && e.target !== nodeId);
                this.showToast('å·²åˆ é™¤èŠ‚ç‚¹');
            }
            
            this.selectedElement = null;
            this.updatePropPanel();
            this.render();
        }
    }

    updateNodeData(id, key, value) {
        const node = this.nodes.find(n => n.id === id);
        if (node) {
            if (key === 'label') node.label = value;
            else if (key === 'isCompleted') node.props.isCompleted = value;
            else node.props[key] = value;
            this.render();
        }
    }

    // ==================== æ¸²æŸ“é€»è¾‘ ====================

    render() {
        const dpr = window.devicePixelRatio || 1;
        // 1. æ¸…ç©ºç”»å¸ƒ (ä½¿ç”¨DPRä¿®å¤åçš„å…¨å°ºå¯¸)
        this.ctx.clearRect(0, 0, this.canvas.width / dpr, this.canvas.height / dpr);

        // 2. åº”ç”¨å¹³ç§»å’Œç¼©æ”¾
        this.ctx.save();
        this.ctx.translate(this.config.panX, this.config.panY);
        this.ctx.scale(this.config.scale, this.config.scale);
        
        // 3. ç»˜åˆ¶èƒŒæ™¯ç½‘æ ¼
        this.drawGrid();

        // 4. ç»˜åˆ¶è¿çº¿
        this.edges.forEach(edge => {
            const sourceNode = this.nodes.find(n => n.id === edge.source);
            const targetNode = this.nodes.find(n => n.id === edge.target);
            if (sourceNode && targetNode) {
                this.drawEdge(sourceNode, targetNode, edge === this.selectedElement);
            }
        });

        // 5. ç»˜åˆ¶ä¸´æ—¶è¿çº¿
        if (this.isLinkMode && this.linkingSource && this.tempLine) {
            this.ctx.beginPath();
            this.ctx.moveTo(this.linkingSource.x, this.linkingSource.y);
            this.ctx.lineTo(this.tempLine.x, this.tempLine.y);
            this.ctx.strokeStyle = '#999';
            this.ctx.setLineDash([5, 5]);
            this.ctx.lineWidth = 2 / this.config.scale; 
            this.ctx.stroke();
            this.ctx.setLineDash([]);
        }

        // 6. ç»˜åˆ¶èŠ‚ç‚¹
        this.nodes.forEach(node => {
            this.drawNode(node, node === this.selectedElement);
        });

        // 7. æ¢å¤ç”»å¸ƒçŠ¶æ€
        this.ctx.restore();
    }
    
    drawGrid() {
        // ... (Grid drawing logic remains the same) ...
        const ctx = this.ctx;
        const size = this.config.gridSize;
        const { width, height } = this.canvas.style; // è·å–CSSå°ºå¯¸
        const w = parseFloat(width) / this.config.scale;
        const h = parseFloat(height) / this.config.scale;
        
        // è®¡ç®—å¹³ç§»åçš„ç½‘æ ¼èµ·ç‚¹
        const startX = (-this.config.panX / this.config.scale) % size;
        const startY = (-this.config.panY / this.config.scale) % size;

        ctx.strokeStyle = 'rgba(221, 221, 221, 0.6)';
        ctx.lineWidth = 1 / this.config.scale; 

        ctx.beginPath();
        // ç»˜åˆ¶å‚ç›´çº¿
        for (let x = startX; x < w; x += size) {
            ctx.moveTo(x, -this.config.panY / this.config.scale);
            ctx.lineTo(x, h - this.config.panY / this.config.scale);
        }
        // ç»˜åˆ¶æ°´å¹³çº¿
        for (let y = startY; y < h; y += size) {
            ctx.moveTo(-this.config.panX / this.config.scale, y);
            ctx.lineTo(w - this.config.panX / this.config.scale, y);
        }
        ctx.stroke();
    }
    
    // æ–‡æœ¬è‡ªåŠ¨æ¢è¡Œå‡½æ•° (ä¿æŒä¸å˜)
    wrapText(ctx, text, x, y, maxWidth, lineHeight) {
        const words = text.split(''); 
        let line = '';
        let lines = [];

        for(let n = 0; n < words.length; n++) {
            const testLine = line + words[n];
            const metrics = ctx.measureText(testLine);
            const testWidth = metrics.width;

            if (testWidth > maxWidth && n > 0) {
                lines.push(line);
                line = words[n];
            } else {
                line = testLine;
            }
        }
        lines.push(line);

        if (lines.length > 2) {
             lines = lines.slice(0, 2);
             let lastLine = lines[1];
             while(ctx.measureText(lastLine + '...').width > maxWidth && lastLine.length > 1) {
                 lastLine = lastLine.substring(0, lastLine.length - 1);
             }
             lines[1] = lastLine + '...';
        }
        
        const totalHeight = lines.length * lineHeight;
        const startY = y - totalHeight / 2 + lineHeight / 2;
        
        lines.forEach((l, index) => {
            ctx.fillText(l, x, startY + index * lineHeight);
        });
    }


    // ç°ä»£åŒ–èŠ‚ç‚¹ç»˜åˆ¶
    drawNode(node, isSelected) {
        const ctx = this.ctx;
        const { x, y, type, label } = node;
        const w = this.config.nodeWidth;
        const h = this.config.nodeHeight;
        const r = this.config.radius;

        ctx.beginPath();
        
        // æ ·å¼è®¾ç½®
        ctx.lineWidth = 1.5 / this.config.scale; 
        ctx.strokeStyle = isSelected ? '#409eff' : (type === 'start' ? '#52c41a' : (type === 'end' ? '#f5222d' : '#dcdfe6'));
        ctx.shadowBlur = isSelected ? 15 : 5; 
        ctx.shadowColor = isSelected ? 'rgba(64, 158, 255, 0.5)' : 'rgba(0,0,0,0.1)';
        
        ctx.fillStyle = '#ffffff'; 

        if (type === 'start' || type === 'end') {
            // åœ†å½¢èŠ‚ç‚¹
            ctx.arc(x, y, r, 0, Math.PI * 2);
            ctx.fillStyle = type === 'start' ? '#f0fff0' : '#fff0f0'; 
            
            // ç»˜åˆ¶å†…éƒ¨è¾¹æ¡†ï¼Œæ¨¡ä»¿åŒé‡åœ†åœˆ
            ctx.save();
            ctx.fillStyle = type === 'start' ? '#52c41a' : '#f5222d'; 
            ctx.shadowBlur = 0; // å†…éƒ¨ä¸åº”æœ‰é˜´å½±
            ctx.arc(x, y, r * 0.9, 0, Math.PI * 2); 
            ctx.fill(); 
            ctx.restore();
            
            // ç»˜åˆ¶å›¾æ ‡
            ctx.fillStyle = '#ffffff'; 
            ctx.font = `bold ${20 / this.config.scale}px "Font Awesome 6 Free"`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            if (type === 'start') {
                ctx.fillText('\uf04b', x, y); // fa-play
            } else if (type === 'end') {
                ctx.fillText('\uf04d', x, y); // fa-stop
            }


        } else {
            // çŸ©å½¢ä»»åŠ¡èŠ‚ç‚¹ (æ›´åœ†æ¶¦)
            const cornerRadius = 12;
            ctx.roundRect(x - w/2, y - h/2, w, h, cornerRadius);
            
            // ç»˜åˆ¶ä»»åŠ¡å®ŒæˆçŠ¶æ€æŒ‡ç¤º
            if (node.props.isCompleted === 'å·²å®Œæˆ') {
                 ctx.fillStyle = '#e8f0e8'; // æµ…ç»¿èƒŒæ™¯
            }
        }

        ctx.fill();
        ctx.stroke();

        // é‡ç½®é˜´å½±
        ctx.shadowBlur = 0;
        ctx.textBaseline = 'alphabetic'; // æ¢å¤é»˜è®¤åŸºçº¿

        // ç»˜åˆ¶æ–‡å­— (ä»»åŠ¡èŠ‚ç‚¹)
        if (type === 'task') {
            ctx.fillStyle = '#333';
            ctx.font = `${14 / this.config.scale}px Arial`; 
            ctx.textAlign = 'center';
            
            const maxTextWidth = w - 20;
            this.wrapText(ctx, label, x, y - 5 / this.config.scale, maxTextWidth, 18 / this.config.scale);

            // ç»åŠäººå°å­— 
            if (node.props.personnel) {
                ctx.font = `${11 / this.config.scale}px Arial`;
                ctx.fillStyle = '#888';
                ctx.textBaseline = 'top'; 
                
                const personnelText = node.props.personnel.split('\n')[0]; // åªæ˜¾ç¤ºç¬¬ä¸€è¡Œ
                ctx.fillText(`ğŸ‘¤ ${personnelText}`, x, y + h / 2 + 5 / this.config.scale);
            }
        }
    }

    drawEdge(source, target, isSelected) {
        const ctx = this.ctx;

        // æ ¸å¿ƒï¼šè®¡ç®—è¿çº¿ä¸èŠ‚ç‚¹è¾¹ç•Œçš„ç²¾ç¡®äº¤ç‚¹
        const intersection = this.getIntersectionPoint(source, target);
        
        let startX = intersection.start.x;
        let startY = intersection.start.y;
        let endX = intersection.end.x;
        let endY = intersection.end.y;
        
        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.lineTo(endX, endY);
        
        ctx.strokeStyle = isSelected ? '#409eff' : '#999';
        ctx.lineWidth = 2 / this.config.scale; 
        ctx.stroke();

        // ç»˜åˆ¶ç®­å¤´
        this.drawArrow(ctx, startX, startY, endX, endY);
    }
    
    // è·å–çº¿æ®µä¸èŠ‚ç‚¹è¾¹ç•Œçš„ç²¾ç¡®äº¤ç‚¹
    getIntersectionPoint(source, target) {
        // åœ†å¿ƒ/çŸ©å½¢ä¸­å¿ƒ
        const p1 = { x: source.x, y: source.y };
        const p2 = { x: target.x, y: target.y };

        const start = this.getBoundaryPoint(source, p2);
        const end = this.getBoundaryPoint(target, p1);

        return { start, end };
    }

    // æ ¹æ®èŠ‚ç‚¹ç±»å‹å’Œç›®æ ‡ç‚¹ï¼Œè®¡ç®—èŠ‚ç‚¹è¾¹ç•Œä¸Šçš„ç‚¹
    getBoundaryPoint(node, targetPoint) {
        const cx = node.x;
        const cy = node.y;
        const dx = targetPoint.x - cx;
        const dy = targetPoint.y - cy;
        const angle = Math.atan2(dy, dx);
        
        if (node.type === 'start' || node.type === 'end') {
            // åœ†å½¢èŠ‚ç‚¹
            const r = this.config.radius;
            return {
                x: cx + r * Math.cos(angle),
                y: cy + r * Math.sin(angle)
            };
        } else {
            // çŸ©å½¢èŠ‚ç‚¹
            const w = this.config.nodeWidth;
            const h = this.config.nodeHeight;
            let finalX, finalY;
            
            // è®¡ç®—ç›´çº¿ä¸çŸ©å½¢å››æ¡è¾¹çš„äº¤ç‚¹
            // t = (w/2) / |cos(angle)| æˆ– t = (h/2) / |sin(angle)|
            const cosA = Math.cos(angle);
            const sinA = Math.sin(angle);
            
            let t = Infinity;

            if (Math.abs(cosA) > 1e-6) {
                t = Math.min(t, Math.abs((w / 2) / cosA));
            }
            if (Math.abs(sinA) > 1e-6) {
                t = Math.min(t, Math.abs((h / 2) / sinA));
            }
            
            finalX = cx + t * cosA;
            finalY = cy + t * sinA;
            
            return { x: finalX, y: finalY };
        }
    }


    drawArrow(ctx, x1, y1, x2, y2) {
        const headLength = 10 / this.config.scale; 
        const angle = Math.atan2(y2 - y1, x2 - x1);
        
        // ç®­å¤´ç”»åœ¨ç»ˆç‚¹ (x2, y2) å¤„
        ctx.beginPath();
        ctx.moveTo(x2, y2);
        ctx.lineTo(x2 - headLength * Math.cos(angle - Math.PI / 6), y2 - headLength * Math.sin(angle - Math.PI / 6));
        ctx.moveTo(x2, y2);
        ctx.lineTo(x2 - headLength * Math.cos(angle + Math.PI / 6), y2 - headLength * Math.sin(angle + Math.PI / 6));
        ctx.stroke();
    }

    // ==================== äº¤äº’é€»è¾‘ ====================
    
    // è¿çº¿ç¢°æ’æ£€æµ‹ (ä¿æŒä¸å˜)
    getEdgeAt(x, y) {
        const distToSegmentSquared = (p, a, b) => {
            const l2 = (b.x - a.x) * (b.x - a.x) + (b.y - a.y) * (b.y - a.y);
            if (l2 === 0) return (p.x - a.x) * (p.x - a.x) + (p.y - a.y) * (p.y - a.y);
            let t = ((p.x - a.x) * (b.x - a.x) + (p.y - a.y) * (b.y - a.y)) / l2;
            t = Math.max(0, Math.min(1, t));
            const projX = a.x + t * (b.x - a.x);
            const projY = a.y + t * (b.y - a.y);
            return (p.x - projX) * (p.x - projX) + (p.y - projY) * (p.y - projY);
        };
        
        for (const edge of this.edges) {
            const source = this.nodes.find(n => n.id === edge.source);
            const target = this.nodes.find(n => n.id === edge.target);
            if (!source || !target) continue;

            // ä½¿ç”¨ç²¾ç¡®è¾¹ç•Œç‚¹è¿›è¡Œæ£€æµ‹
            const intersection = this.getIntersectionPoint(source, target);
            const distSq = distToSegmentSquared({ x, y }, intersection.start, intersection.end);

            if (distSq < 100 / (this.config.scale * this.config.scale)) { 
                return edge;
            }
        }
        return null;
    }


    handleMouseDown(e) {
        const { offsetX, offsetY } = e;
        const { realX, realY } = this.getCanvasCoords(offsetX, offsetY);
        
        const clickedNode = this.getNodeAt(realX, realY);
        const clickedEdge = !clickedNode ? this.getEdgeAt(realX, realY) : null;
        
        
        if (this.isLinkMode) {
            if (clickedNode) {
                // è¿çº¿æ¨¡å¼ä¸‹ï¼Œæ£€æŸ¥æ˜¯å¦å¯ä»¥ä½œä¸ºèµ·ç‚¹
                if (clickedNode.type === 'end') {
                    this.showToast('ä¸å…è®¸ä» "ç»“æŸèŠ‚ç‚¹" è¿å‡º');
                    this.selectElement(clickedNode);
                    return;
                }
                this.linkingSource = clickedNode;
                this.selectElement(clickedNode);
            } else {
                this.selectElement(null);
            }
        } else {
            if (clickedNode) {
                this.isDragging = true;
                this.dragTarget = clickedNode;
                this.selectElement(clickedNode);
            } else if (clickedEdge) {
                this.selectElement(clickedEdge);
                this.isDragging = false; 
                
            } else {
                this.isDragging = true;
                this.dragTarget = { isCanvas: true, lastX: offsetX, lastY: offsetY };
                this.selectElement(null);
            }
        }
        this.render();
    }

    handleMouseMove(e) {
        const { offsetX, offsetY } = e;
        const { realX, realY } = this.getCanvasCoords(offsetX, offsetY);

        if (this.isLinkMode && this.linkingSource) {
            this.tempLine = { x: realX, y: realY };
            this.render();
        } else if (this.isDragging) {
            if (this.dragTarget.isCanvas) {
                // ç”»å¸ƒå¹³ç§»
                this.config.panX += offsetX - this.dragTarget.lastX;
                this.config.panY += offsetY - this.dragTarget.lastY;
                this.dragTarget.lastX = offsetX;
                this.dragTarget.lastY = offsetY;
                this.render();
            } else if (this.dragTarget) {
                // èŠ‚ç‚¹æ‹–åŠ¨ï¼šè®¡ç®—ä¸–ç•Œåæ ‡ä¸‹çš„æ–°ä½ç½®
                this.dragTarget.x = (offsetX - this.config.panX) / this.config.scale;
                this.dragTarget.y = (offsetY - this.config.panY) / this.config.scale;
                this.render();
            }
        }
    }

    handleMouseUp(e) {
        const { offsetX, offsetY } = e;
        const { realX, realY } = this.getCanvasCoords(offsetX, offsetY);

        if (this.isLinkMode && this.linkingSource) {
            const targetNode = this.getNodeAt(realX, realY);
            if (targetNode && targetNode.id !== this.linkingSource.id) {
                this.addEdge(this.linkingSource.id, targetNode.id);
            }
            
            this.linkingSource = null;
            this.tempLine = null;
            this.isLinkMode = false;
            document.getElementById('linkModeBtn').style.background = '#fff';
            document.getElementById('linkModeBtn').style.borderColor = '#f0f0f0';
            this.render();
        }
        
        this.isDragging = false;
        this.dragTarget = null;
    }

    getNodeAt(x, y) {
        for (let i = this.nodes.length - 1; i >= 0; i--) {
            const n = this.nodes[i];
            const w = this.config.nodeWidth;
            const h = this.config.nodeHeight;

            if (n.type === 'start' || n.type === 'end') {
                // åœ†å½¢ç¢°æ’æ£€æµ‹
                const dx = x - n.x;
                const dy = y - n.y;
                if (dx*dx + dy*dy <= this.config.radius * this.config.radius) return n;
            } else {
                // çŸ©å½¢ç¢°æ’æ£€æµ‹
                if (x >= n.x - w/2 && x <= n.x + w/2 &&
                    y >= n.y - h/2 && y <= n.y + h/2) return n;
            }
        }
        return null;
    }

    selectElement(el) {
        this.selectedElement = el;
        this.updatePropPanel();
    }

    toggleLinkMode() {
        this.isLinkMode = !this.isLinkMode;
        const btn = document.getElementById('linkModeBtn');
        if (this.isLinkMode) {
             btn.style.background = '#ecf5ff';
             btn.style.borderColor = '#409eff';
        } else {
             btn.style.background = '#fff';
             btn.style.borderColor = '#f0f0f0';
        }
        this.showToast(this.isLinkMode ? 'è¿›å…¥è¿çº¿æ¨¡å¼ï¼šç‚¹å‡»å¹¶æ‹–æ‹½è¿æ¥' : 'é€€å‡ºè¿çº¿æ¨¡å¼');
    }

    // ==================== UI æ›´æ–° (å±æ€§é¢æ¿) ====================

    updatePropPanel() {
        const panel = document.getElementById('propContent');
        if (!this.selectedElement) {
            panel.innerHTML = '<div class="empty-state">è¯·ç‚¹å‡»é€‰æ‹©èŠ‚ç‚¹æˆ–è¿çº¿</div>';
            return;
        }

        // å¦‚æœé€‰ä¸­çš„æ˜¯è¿çº¿
        if (this.selectedElement.source) {
            const edge = this.selectedElement;
            const sourceNode = this.nodes.find(n => n.id === edge.source);
            const targetNode = this.nodes.find(n => n.id === edge.target);
            panel.innerHTML = `
                <div class="form-group">
                    <label>è¿çº¿ ID (ä¸å¯ä¿®æ”¹)</label>
                    <input type="text" value="${edge.id}" disabled style="background:#f5f5f5">
                </div>
                <div class="form-group">
                    <label>èµ·ç‚¹: ${sourceNode ? sourceNode.label || sourceNode.type : 'æœªçŸ¥'}</label>
                    <input type="text" value="${edge.source}" disabled style="background:#f5f5f5">
                </div>
                <div class="form-group">
                    <label>ç»ˆç‚¹: ${targetNode ? targetNode.label || targetNode.type : 'æœªçŸ¥'}</label>
                    <input type="text" value="${edge.target}" disabled style="background:#f5f5f5">
                </div>
                <div style="margin-top:25px; border-top:1px solid #eee; padding-top:25px;">
                     <button class="btn btn-danger" style="width:100%" onclick="app.deleteSelected()">åˆ é™¤å½“å‰è¿çº¿</button>
                </div>
            `;
            return;
        }


        // å¦‚æœé€‰ä¸­çš„æ˜¯èŠ‚ç‚¹
        if (this.selectedElement.x !== undefined) {
            const node = this.selectedElement;
            panel.innerHTML = `
                <div class="form-group">
                    <label>ID (ä¸å¯ä¿®æ”¹)</label>
                    <input type="text" value="${node.id}" disabled style="background:#f5f5f5">
                </div>
                <div class="form-group">
                    <label>èŠ‚ç‚¹ç±»å‹</label>
                    <input type="text" value="${node.type === 'start' ? 'æµç¨‹å¼€å§‹' : (node.type === 'end' ? 'æµç¨‹ç»“æŸ' : 'ä»»åŠ¡å®¡æ‰¹')}" disabled style="background:#f5f5f5">
                </div>
                ${node.type === 'task' ? `
                <div class="form-group">
                    <label>èŠ‚ç‚¹åç§°</label>
                    <input type="text" id="inputLabel" value="${node.label}" oninput="app.updateNodeData('${node.id}', 'label', this.value)">
                </div>
                <div class="form-group">
                    <label>ç»åŠäººå‘˜/è§’è‰² (æ¯è¡Œä¸€ä¸ª)</label>
                    <textarea 
                        rows="3" 
                        oninput="app.updateNodeData('${node.id}', 'personnel', this.value)"
                    >${node.props.personnel}</textarea>
                </div>
                <div class="form-group">
                    <label>ä»»åŠ¡å®ŒæˆçŠ¶æ€</label>
                    <select onchange="app.updateNodeData('${node.id}', 'isCompleted', this.value)">
                        <option value="æœªå®Œæˆ" ${node.props.isCompleted === 'æœªå®Œæˆ' ? 'selected' : ''}>æœªå®Œæˆ (é»˜è®¤)</option>
                        <option value="å·²å®Œæˆ" ${node.props.isCompleted === 'å·²å®Œæˆ' ? 'selected' : ''}>å·²å®Œæˆ</option>
                    </select>
                </div>
                ` : ''}
                <div style="margin-top:25px; border-top:1px solid #eee; padding-top:25px;">
                     <button class="btn btn-danger" style="width:100%" onclick="app.deleteSelected()">åˆ é™¤å½“å‰èŠ‚ç‚¹</button>
                </div>
            `;
        }
    }

    showToast(msg) {
        const t = document.getElementById('toast');
        t.innerText = msg;
        t.style.display = 'block';
        setTimeout(() => t.style.display = 'none', 2000);
    }

    // ==================== å¯¼å…¥å¯¼å‡º & æ ¡éªŒ ====================

    validateWorkflow() {
        let isValid = true;
        const taskNodes = this.nodes.filter(n => n.type === 'task');
        
        console.group('å·¥ä½œæµæ ¡éªŒç»“æœ');
        
        // 1. æ£€æŸ¥ä»»åŠ¡èŠ‚ç‚¹åç§°æ˜¯å¦ä¸ºç©º
        taskNodes.forEach(node => {
            if (!node.label || node.label.trim() === '') {
                console.warn(`[WARN] ä»»åŠ¡èŠ‚ç‚¹ID: ${node.id} ç¼ºå°‘åç§°.`);
                isValid = false;
            }
        });
        
        // 2. æ£€æŸ¥æ˜¯å¦æœ‰ä¸”ä»…æœ‰ä¸€ä¸ªèµ·å§‹èŠ‚ç‚¹
        const startNodes = this.nodes.filter(n => n.type === 'start');
        if (startNodes.length !== 1) {
             console.error(`[ERROR] å¿…é¡»æœ‰ä¸”ä»…æœ‰ä¸€ä¸ª 'å¼€å§‹' èŠ‚ç‚¹ã€‚å½“å‰æ•°é‡: ${startNodes.length}`);
             isValid = false;
        }

        // 3. æ£€æŸ¥æ˜¯å¦æœ‰è‡³å°‘ä¸€ä¸ªç»“æŸèŠ‚ç‚¹
        const endNodes = this.nodes.filter(n => n.type === 'end');
        if (endNodes.length === 0) {
            console.error(`[ERROR] æµç¨‹å¿…é¡»æœ‰è‡³å°‘ä¸€ä¸ª 'ç»“æŸ' èŠ‚ç‚¹ã€‚`);
            isValid = false;
        }

        console.log(`æ ¡éªŒçŠ¶æ€: ${isValid ? 'é€šè¿‡' : 'æœªé€šè¿‡'}`);
        console.groupEnd();
        
        return isValid;
    }

    saveData() {
        const isValid = this.validateWorkflow();
        
        const data = {
            nodes: this.nodes,
            edges: this.edges,
            validation: isValid ? 'PASS' : 'FAIL'
        };
        const json = JSON.stringify(data, null, 2);
        console.log('Submission Data:', json);
        
        alert(`å·¥ä½œæµæ•°æ®å·²ç”Ÿæˆã€‚\næ ¡éªŒç»“æœ: ${isValid ? 'é€šè¿‡ âœ…' : 'æœªé€šè¿‡ âŒ'}\nè¯·æŸ¥çœ‹æ§åˆ¶å°è¾“å‡ºæˆ–å¤åˆ¶ä¸‹æ–¹JSON.`);
        return data;
    }

    clear() {
        if (confirm('ç¡®å®šæ¸…ç©ºç”»å¸ƒå—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚')) {
            this.nodes = [];
            this.edges = [];
            this.selectElement(null);
            this.render();
            this.showToast('ç”»å¸ƒå·²æ¸…ç©º');
        }
    }

    loadDemoData() {
        const demoData = {
            "nodes": [
                {"id": "n1", "type": "start", "x": 120, "y": 250, "label": "", "props": {"personnel": "", "isCompleted": "N/A"}},
                {"id": "n2", "type": "task", "x": 380, "y": 250, "label": "éƒ¨é—¨ç»ç†å®¡æ‰¹", "props": {"personnel": "å°ç‹ (ç»åŠ)\næå (å¤‡é€‰)", "isCompleted": "æœªå®Œæˆ"}},
                {"id": "n3", "type": "task", "x": 640, "y": 250, "label": "CEO æœ€ç»ˆæ‰¹å‡†", "props": {"personnel": "ææ€» (è§’è‰²)", "isCompleted": "å·²å®Œæˆ"}},
                {"id": "n4", "type": "task", "x": 900, "y": 250, "label": "è´¢åŠ¡å¤‡æ¡ˆ", "props": {"personnel": "èµµè´¢åŠ¡", "isCompleted": "æœªå®Œæˆ"}},
                {"id": "n5", "type": "end", "x": 1100, "y": 250, "label": "", "props": {"personnel": "", "isCompleted": "N/A"}}
            ],
            "edges": [
                {"id": "e1", "source": "n1", "target": "n2", "label": ""},
                {"id": "e2", "source": "n2", "target": "n3", "label": ""},
                {"id": "e3", "source": "n3", "target": "n4", "label": ""},
                {"id": "e4", "source": "n4", "target": "n5", "label": ""}
            ]
        };

        this.nodes = demoData.nodes;
        this.edges = demoData.edges;
        this.selectedElement = null;
        this.updatePropPanel();
        this.render();
        this.showToast('Demoæ•°æ®å·²åŠ è½½');
    }
}

// Polyfill for roundRect
if (!CanvasRenderingContext2D.prototype.roundRect) {
    CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
        if (w < 2 * r) r = w / 2;
        if (h < 2 * r) r = h / 2;
        this.beginPath();
        this.moveTo(x + r, y);
        this.arcTo(x + w, y, x + w, y + h, r);
        this.arcTo(x + w, y + h, x, y + h, r);
        this.arcTo(x, y + h, x, y, r);
        this.arcTo(x, y, x + w, y, r);
        this.closePath();
        return this;
    };
}

// åˆå§‹åŒ–åº”ç”¨
const app = new WorkflowDesigner('workflowCanvas', 'canvasContainer');

</script>
</body>
</html>